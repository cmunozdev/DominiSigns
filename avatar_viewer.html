<!DOCTYPE html>
<html>

<head>
    <title>DominiSigns - Avatar Animation Prototype</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #222;
            color: white;
            font-family: sans-serif;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
        }

        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            display: none;
        }

        input {
            pointer-events: auto;
        }
    </style>
    <!-- Import Maps Polyfill -->
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "./libs/three.module.js?v=2",
                "three/addons/": "./libs/",
                "kalidokit": "./libs/kalidokit.es.js?v=2"
            }
        }
    </script>
</head>

<body>
    <div id="info">
        <h2>DominiSigns Avatar Viewer</h2>
        <p>1. Drop JSON pose file<br>2. Watch Avatar move</p>
    </div>
    <div id="loading">Loading Avatar...</div>
    <div id="controls">
        <button id="playBtn">Play</button>
        <button id="pauseBtn">Pause</button>
        <span id="frameDisplay">Frame: 0</span>
        <br>
        <input type="file" id="fileInput" accept=".json">
    </div>
    <div id="error-log"
        style="position: absolute; top: 0; right: 0; background: rgba(255,0,0,0.8); color: white; padding: 10px; display: none; max-width: 300px;">
    </div>

    <script>
        // Override console.log and error to show on screen
        const logDiv = document.getElementById('error-log');

        function showLog(msg, color = 'white') {
            logDiv.style.display = 'block';
            logDiv.innerHTML += `<div style="color:${color}; border-bottom:1px solid #444; margin-bottom:2px;">${msg}</div>`;
        }

        const originalLog = console.log;
        console.log = function (...args) {
            originalLog.apply(console, args);
            showLog("LOG: " + args.join(' '));
        };

        const originalError = console.error;
        console.error = function (...args) {
            originalError.apply(console, args);
            showLog("ERR: " + args.join(' '), 'red');
        };

        window.onerror = function (msg, url, line, col, error) {
            showLog(`CRASH: ${msg} <br> Line: ${line}`, 'red');
            return false;
        };

        showLog("System starting...");
    </script>

    <script type="module">
        showLog("Module script started");

        import * as THREE from 'three';
        showLog("Three.js imported");

        import { OrbitControls } from 'three/addons/OrbitControls.js';
        showLog("OrbitControls imported");

        import { GLTFLoader } from 'three/addons/GLTFLoader.js';
        showLog("GLTFLoader imported");

        import * as Kalidokit from 'kalidokit';
        showLog("Kalidokit imported");

        let scene, camera, renderer, clock;
        let avatarModel, currentVrm;
        let mixer;
        let animationData = null;
        let currentFrame = 0;
        let isPlaying = false;
        let lastTime = 0;
        let fps = 30;

        // Public avatar model (Three.js Soldier example with Mixamo rig)
        const AVATAR_URL = 'https://threejs.org/examples/models/gltf/Soldier.glb';

        function init() {
            clock = new THREE.Clock();
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333);

            // Lights
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 2);
            hemiLight.position.set(0, 20, 0);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 2);
            dirLight.position.set(3, 10, 10);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // Camera
            camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1.4, 3);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            document.body.appendChild(renderer.domElement);

            // Controls
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 1, 0);
            controls.update();

            // Load Avatar
            loadAvatar();

            // UI Events
            window.addEventListener('resize', onWindowResize, false);
            document.getElementById('fileInput').addEventListener('change', handleFileSelect, false);
            document.getElementById('playBtn').addEventListener('click', () => isPlaying = true);
            document.getElementById('pauseBtn').addEventListener('click', () => isPlaying = false);

            document.body.addEventListener('dragover', (e) => e.preventDefault());
            document.body.addEventListener('drop', (e) => {
                e.preventDefault();
                if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
            });

            animate();
        }

        function loadAvatar() {
            document.getElementById('loading').style.display = 'block';
            const loader = new GLTFLoader();
            loader.load(AVATAR_URL, (gltf) => {
                avatarModel = gltf.scene;
                avatarModel.traverse((o) => {
                    if (o.isMesh) {
                        o.castShadow = true;
                        o.receiveShadow = true;
                    }
                });
                scene.add(avatarModel);
                document.getElementById('loading').style.display = 'none';
                console.log("Avatar loaded");
            }, undefined, (e) => {
                console.error(e);
                document.getElementById('loading').textContent = "Error loading avatar";
            });
        }

        function handleFileSelect(evt) {
            handleFile(evt.target.files[0]);
        }

        function handleFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    animationData = JSON.parse(e.target.result);
                    fps = animationData.fps || 30;
                    currentFrame = 0;
                    isPlaying = true;
                    console.log("Loaded frames:", animationData.frames.length);
                } catch (err) {
                    alert("Error parsing JSON");
                }
            };
            reader.readAsText(file);
        }

        function animate(time) {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            if (isPlaying && animationData && avatarModel) {
                const interval = 1000 / fps;
                if (time - lastTime > interval) {
                    currentFrame = (currentFrame + 1) % animationData.frames.length;
                    document.getElementById('frameDisplay').innerText = `Frame: ${currentFrame}`;
                    applyPose(animationData.frames[currentFrame]);
                    lastTime = time;
                }
            }

            renderer.render(scene, camera);
        }

        function applyPose(frame) {
            if (!frame || !avatarModel) return;

            // MediaPipe Holistic result format expected by Kalidokit
            // We need to reconstruct the "results" object structure
            // Kalidokit expects normalized landmarks

            // Basic mapping logic (Kalidokit.Event.solve or manual bone rotation)
            // Note: Kalidokit expects the full result object usually. 
            // Since we stored arrays, we map back to MP format.

            const pose3D = frame.poseKeypoints3D || frame.pose; // handle our json format
            const face = frame.face;
            const leftHand = frame.left_hand;
            const rightHand = frame.right_hand;

            // We need to convert our stored array of {x,y,z,visibility} back to what Kalidokit expects
            // Kalidokit expects: poseLandmarks, faceLandmarks, leftHandLandmarks, rightHandLandmarks

            // Helper to format
            const formatLM = (arr) => arr ? arr.map(l => ({ x: l.x, y: l.y, z: l.z, visibility: l.visibility ?? 1 })) : undefined;

            const solved = Kalidokit.Pose.solve(formatLM(pose3D), formatLM(pose3D), {
                runtime: 'mediapipe',
                video: null,
                imageSize: { width: 640, height: 480 } // arbitrary, used for aspect ratio
            });

            const solvedRightHand = Kalidokit.Hand.solve(formatLM(rightHand), "Right");
            const solvedLeftHand = Kalidokit.Hand.solve(formatLM(leftHand), "Left");

            // Apply to bones
            // This requires finding the bones in the GLTF scene.
            // Ready Player Me uses standard mixamo/humanoid naming mostly.

            if (solved) {
                // Hips, Spine, Shoulders, etc.
                rigRotation("Hips", solved.Hips);
                rigRotation("Spine", solved.Spine);
                rigRotation("Spine1", solved.Spine1);
                rigRotation("Spine2", solved.Spine2);
                rigRotation("Neck", solved.Neck);
                rigRotation("Head", solved.Head);

                rigRotation("RightArm", solved.RightUpperArm);
                rigRotation("RightForeArm", solved.RightLowerArm);
                rigRotation("LeftArm", solved.LeftUpperArm);
                rigRotation("LeftForeArm", solved.LeftLowerArm);

                // Legs
                rigRotation("RightUpLeg", solved.RightUpperLeg);
                rigRotation("RightLeg", solved.RightLowerLeg);
                rigRotation("LeftUpLeg", solved.LeftUpperLeg);
                rigRotation("LeftLeg", solved.LeftLowerLeg);
            }

            if (solvedRightHand) {
                rigRotation("RightHand", solvedRightHand.RightWrist);
                // Fingers... this is where it gets tedious without a helper class
                // For this prototype, let's just do wrist rotation
            }
            if (solvedLeftHand) {
                rigRotation("LeftHand", solvedLeftHand.LeftWrist);
            }
        }

        const boneMap = {
            "Hips": "Hips",
            "Spine": "Spine",
            "Spine1": "Spine1",
            "Spine2": "Spine2",
            "Neck": "Neck",
            "Head": "Head",
            "RightArm": "RightArm",
            "RightForeArm": "RightForeArm",
            "RightHand": "RightHand",
            "LeftArm": "LeftArm",
            "LeftForeArm": "LeftForeArm",
            "LeftHand": "LeftHand",
            "RightUpLeg": "RightUpLeg",
            "RightLeg": "RightLeg",
            "RightFoot": "RightFoot",
            "LeftUpLeg": "LeftUpLeg",
            "LeftLeg": "LeftLeg",
            "LeftFoot": "LeftFoot"
        };

        function rigRotation(name, rotation) {
            if (!rotation) return;
            const boneName = boneMap[name];
            const bone = avatarModel.getObjectByName(boneName) || avatarModel.getObjectByName("Mixamo:" + boneName);

            if (bone) {
                // Kalidokit gives quaternions or euler. Usually Quaternion.
                // We need to be careful with coordinate systems.
                // Kalidokit output is: x, y, z, w
                const q = new THREE.Quaternion(rotation.x, rotation.y, rotation.z, rotation.w);
                bone.quaternion.slerp(q, 0.5); // Smooth interpolation
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Start the application
        showLog("Calling init()...");
        init();
        showLog("Init complete, avatar loading...");
    </script>
</body>

</html>