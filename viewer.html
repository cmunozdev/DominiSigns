<!DOCTYPE html>
<html>
<head>
    <title>DominiSigns - Pose Data Viewer</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; color: white; font-family: sans-serif; }
        #info { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; }
        #controls { position: absolute; bottom: 10px; left: 10px; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="info">
        <h2>DominiSigns Data Viewer</h2>
        <p>Drop a JSON file here or use the file input.</p>
        <input type="file" id="fileInput" accept=".json">
    </div>
    <div id="controls">
        <button id="playBtn">Play</button>
        <button id="pauseBtn">Pause</button>
        <span id="frameDisplay">Frame: 0</span>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let points = [];
        let animationData = null;
        let currentFrame = 0;
        let isPlaying = false;
        let lastTime = 0;
        let fps = 30;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);
            scene.add(new THREE.GridHelper(10, 10));
            scene.add(new THREE.AxesHelper(1));

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.5, 3);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 1, 0);
            controls.update();

            // Create points pool
            // 33 pose + 21*2 hands + 468 face = ~543 points
            const geometry = new THREE.SphereGeometry(0.02, 8, 8);
            const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            
            for(let i=0; i<600; i++) {
                const mesh = new THREE.Mesh(geometry, material);
                mesh.visible = false;
                scene.add(mesh);
                points.push(mesh);
            }

            window.addEventListener('resize', onWindowResize, false);
            setupUI();
            animate();
        }

        function setupUI() {
            document.getElementById('fileInput').addEventListener('change', handleFileSelect, false);
            document.getElementById('playBtn').addEventListener('click', () => isPlaying = true);
            document.getElementById('pauseBtn').addEventListener('click', () => isPlaying = false);
            
            // Drag and drop
            document.body.addEventListener('dragover', (e) => e.preventDefault());
            document.body.addEventListener('drop', (e) => {
                e.preventDefault();
                if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
            });
        }

        function handleFileSelect(evt) {
            handleFile(evt.target.files[0]);
        }

        function handleFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    animationData = JSON.parse(e.target.result);
                    fps = animationData.fps || 30;
                    currentFrame = 0;
                    if (animationData.frames && animationData.frames.length > 0) {
                        console.log("Loaded frames:", animationData.frames.length);
                        isPlaying = true;
                    }
                } catch(err) {
                    alert("Error parsing JSON: " + err);
                }
            };
            reader.readAsText(file);
        }

        function updatePoints(frameIdx) {
            if (!animationData || !animationData.frames || frameIdx >= animationData.frames.length) return;
            
            const frame = animationData.frames[frameIdx];
            let pIdx = 0;

            // Helper to set point
            const setP = (lm, color) => {
                const p = points[pIdx++];
                if (p) {
                    // MediaPipe coords: x (0-1), y (0-1), z (depth)
                    // Visualizer: flip y (screen coords to 3D), center around 0
                    p.position.set(
                        (lm.x - 0.5) * 2, 
                        -(lm.y - 0.5) * 2 + 1.5, 
                        -lm.z * 2
                    );
                    p.material.color.setHex(color);
                    p.visible = true;
                }
            };

            // Pose (Red)
            if (frame.pose) frame.pose.forEach(lm => setP(lm, 0xff0000));
            // Left Hand (Green)
            if (frame.left_hand) frame.left_hand.forEach(lm => setP(lm, 0x00ff00));
            // Right Hand (Blue)
            if (frame.right_hand) frame.right_hand.forEach(lm => setP(lm, 0x0000ff));
            // Face (Yellow - subset to save perf/visuals)
            if (frame.face) {
                 // only draw some face points
                 frame.face.forEach((lm, i) => {
                     if (i % 10 === 0) setP(lm, 0xffff00);
                 });
            }

            // Hide unused points
            for(let i=pIdx; i<points.length; i++) points[i].visible = false;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate(time) {
            requestAnimationFrame(animate);

            if (isPlaying && animationData) {
                const interval = 1000 / fps;
                if (time - lastTime > interval) {
                    currentFrame = (currentFrame + 1) % animationData.frames.length;
                    document.getElementById('frameDisplay').innerText = `Frame: ${currentFrame}`;
                    lastTime = time;
                }
            }
            
            updatePoints(currentFrame);
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
